客户端基本流程
在 15s 内没有读或者写事件，IdleStateHandler 就会发布一个 IdleStateEvent 事件
HeartbeatHandler 进行该事件的处理：
首先从当前 Channel 的附属属性中获取相关的 ProtocolCode
再从 ProtocolManager 中获取 ProtocolCode 的 Protocol 实现类
再从 Protocol 实现类获取 HeartbeatTrigger 实例，最终调用该实例进行 IdleStateEvent 的处理
HeartbeatTrigger 处理 IdleStateEvent 事件
首先从当前 Channel 的附属属性中获取已经发送心跳但是没有接收到响应的次数 heartbeatTimes，如果 heartbeatTimes 已经大于 3 次，则直接关闭连接，否则
从当前 Channel 的附属属性中获取心跳开关，如果关闭了心跳，则直接返回，表示对 IdleStateEvent 不做任何处理；如果开启了心跳
创建心跳请求命令 HeartbeatCommand + 创建本次请求的 InvokeFuture 对象 + 将 InvokeFuture 对象加入到当前的 Connection 中
InvokeFuture 中会设置心跳响应回调函数：当接收到了正常的心跳响应后，将 heartbeatTimes 置为 0；否则，将该连接的heartbeatTimes+1

使用 Netty 发送 HeartbeatCommand 到服务端
设置超时任务（1s内没有接收到心跳响应，则直接返回超时失败响应，实现快速失败）

IdleStateHandler
服务端基本流程
 在 90s 内没有读或者写事件，IdleStateHandler 就会发布一个 IdleStateEvent 事件（如果客户端还正常，那么在 90s 内，会发送至少 6 次心跳，那么服务端将不会触发 IdleStateEvent 事件）
 ServerIdleHandler 进行该事件的处理：直接关闭连接
 
心跳处理流程

心跳请求的处理：服务端接收到 HeartbeatCommand 后，构造心跳响应 HeartbeatAckCommand，之后使用 Netty 返回 HeartbeatAckCommand 给客户端
心跳响应的处理：客户端接收到 HeartbeatAckCommand 后，设置心跳响应消息到 InvokeFuture + 取消超时任务 + 执行 InvokeFuture 中的回调方法


只有客户端会主动发送心跳请求；但是双端都会开启空闲检测
心跳除了上述应用端提供的这种之外，还有 tcp 提供的 keepAlive